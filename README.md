https://www.amazon.co.jp/GitHub-CI-CD%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89%E2%80%95%E2%80%95%E6%8C%81%E7%B6%9A%E5%8F%AF%E8%83%BD%E3%81%AA%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%E3%82%92%E6%94%AF%E3%81%88%E3%82%8BGitHub-Actions%E3%81%AE%E8%A8%AD%E8%A8%88%E3%81%A8%E9%81%8B%E7%94%A8-%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E9%81%B8%E6%9B%B8-ebook/dp/B0D4DBYJJ9/ref=sr_1_1?adgrpid=52355088214&dib=eyJ2IjoiMSJ9.0YRCa0noJUqJRIOpdScZAeOzBOL0D8mQM3YntRrVusQbsgRzltO8jQpdVHSmZnGelJ-HDkotV0ctdHJhwziilwffAD1RABl_eTDevh6KeStGWiJB0dhOb9vOpbZsi3k6UK_4IvwrF3kCeALL7tzDiOaRE7I-y7MK84WV3Txk3jsA2W7WmL1RaL5AYnKgAoBiBJwPZ1o0l_JqJ2GBOnGn1x45-3VqBbiK_-ZXNcbrA12HT8_zc5yE3vu_hSbYHibC3DkC-nzeJ7lpcyc2yu-4hwXZfX70KCXzmPxRAovwEYE.rnezGeOskNn38zoUUJJ2vHzQKT8kIiExU2fITm67yH4&dib_tag=se&hvadid=678984764322&hvdev=c&hvexpln=0&hvlocphy=1009685&hvnetw=g&hvocijid=7845953081516880182--&hvqmt=e&hvrand=7845953081516880182&hvtargid=kwd-2416285783434&hydadcr=27270_14738616&jp-ad-ap=0&keywords=github+ci+cd%E5%AE%9F%E8%B7%B5%E3%82%AC%E3%82%A4%E3%83%89&mcid=0b1369eb3d3e373d975268c34dd188f9&qid=1754828573&sr=8-1

# まとめ
## 2章
- GitHub Actions
  - 自動化にかつようできる、汎用的なワークフローエンジン
- ワークフローファイルは、YAML形式で `.github/workflows` に配置
- GitHub-Hosted Runners は、Ubuntu, Windows, macOS が利用できる
- GitHub Marketplace で、再利用可能なコンポーネントである「アクション」を検索できる
  - Verified Creators はアクション選択の判断材料になる
- パブリックリポジトリであれば無料
  - プライベートリポジトリは、使用時間とストレージ使用量に応じた従量課金
## 3章
- コンテキストコンテキスtおやデフォルト環境変数から、ワークフロー実行時の情報などが取得できる
  - コンテキストの参照は、中間環境変数を使うと安全
- ステップ名やワークフロー実行名をつけると、コードやログが読みやすくなる
  - 環境変数 `GITHUB_OUTPUT` や `GITHUB_ENV` を使うと、ステップ間でデータ共有ができる
  - こだわりがなければ、可読性の高い `GITHUB_OUTPUT` を利用する
- `GITHUB_TOKEN` は、ワークフロー実行時に自動生成されるクレデンシャル
 - GitHub API のアクセスに利用できる
 - アクセス許可するリソースや操作はパーミッションで定義する
    - 自リポジトリ以外にはアクセスできない
- スターターワークフローでは、便利なリファレンス実装が提供されている
## 4章
- テストワークフローの基本形は、チェックアウト・言語セットアップ・テストの3ステップ
- PR ページからワークフローのステータスチェックが可能
- フィルターやアクティビティタイプで、ワークフローの起動条件を制御できる
- セットアップアクションで使用する言語バージョンを指定可能
- キャッシュを有効にするとワークフロー実行の高速化
- actionslint を使えば、ワークフローファイルに対して静的解析ができる
- 常にタイムアウトを設定すること。デフォルトタイムアウトは6時間
- シェル指定で Bash の起動オプションが変わる。パイプエラーを拾うため、常にデフォルトシェルを定義すること
- Concurrency を使えば多重起動の抑制や、自動キャンセルができる
- CI の黄金律は、「クリーンに保つ」「高速に実行する」「ノイズを減らす」の3つ
- フレーキーテストやフラジャイルテストの放置は現金
- 静的解析の警告を無視しない。不要なら抑制する。
## 5章
- ステップデバッグログとランナー診断ログを出力できる
  - ワークフローコマンドを使うと、自分でもデバッグログを出力できる
- Bash のトレーシングオプションを使うことで手軽に情報量を増やせる
  - ログ流量が多い場合はグループ化
- アノテーションやジョブサマリーで、重要な情報を素早く確認できる
- チャット通知でタイムリーな情報把握
- 複数ジョブを起動すると、デフォルトで並列実行される。逐次実行したい場合は、ジョブの依存関係を定義する。
  - ジョブ間のデータ受渡可能
- キャッシュアクションで細かくキャッシュを制御する
  - キャッシュキーの設計が重要
  - キャッシュは手動でも削除可能
## 6章
- アクション実装は、Composite Actions・JavaScript Actions・Docker Container Actions のいずれかで実装
  - Composite Action がもっとも簡単
- リモートアクションは独立したリポジトリへ配置し、ローカルアクションはワークフローと同じリポジトリに配置する
- アクションの可読性は、リポジトリの可読性と連動している
- アクションにはメタデータファイルが必須
  - メタデータ構文にはメインロジックや入出力インタフェースを記述する
- メタデータ構文はワークフロー構文と違い、shell キーが省略できなかったり、Variables や Secrets へアクセスできない
- 認知負荷を下げるため、アクションの名前と概要にごだわること
- `GITHUB_TOKEN` が必要なら、`github.token` プロパティを使う
- 切り出したスクリプトの参照には、`GITHUB_ACTION_PATH` を使う
- アクションでは環境変数への依存を避け、ログはグループ化すること
## 7章
- CODEOWNERS ファイルにより、レビュー依頼を自動化できる
- シークレットスキャンを使うと、クレデンシャルの混入を検出できる
## 8章
- 依存関係のバージョンアップには Dependendabot が役立つ
  - パッケージエコシステムや、バージョンアップスケジュールを設定できる
  - 特定の依存関係や特定バージョンの除外も可能
- Dependabot が起動するワークフローでは、通常の Secrets は参照できない。Dependabot secrets を別途登録する
- 依存関係のメタデータは、自動マージの細かい制御に役立つ
- バージョンアップの難易度は、「破壊的変更の頻度」「ソフトウェアの依存度合い」「自動テストの充実度」などで変わる
## 9章
- アナウンスにはリリースノートや Changelog が慣例的によく使われる。後方互換性の有無などでカテゴライズすると、変更内容がわかりやすくなる
- GitHub Releases を使うと、リリースノートやアセット簡単に配信できる
- GitHub Releases ではリリースノートの自動性せも可能。ただし、読む価値がある内容になっているかを自分で確認すべき
- GitHub Actions から GitHub Releases を操作すれば、リリースが自動できる
- ルールセットを設定すると、 Git タグを変更や削除から保護できる
## 10章
- GitHub Packages はマネージドなパッケージレジストリ。複数の言語パッケージと、コンテナイメージを扱える
- Container Registry ではコンテナイメージを管理する。GitHub のクレデンシャルを使って、Docker 経由で操作可能
- パッケージとリポジトリは論理的に別リソース
- パッケージとリポジトリをリンクすると、パーミッション設定が継承できる。自動リンク機能により、パーミッション管理が楽になる
- 可視性のデフォルトはプライベート。自動リンクによる継承はできない
- コンテナイメージを扱う場合、Docker が提供するアクションを利用すること
## 11章
- クラウドプロバイダへのアクセスには、OpenID Connect を使う。静的クレデンシャルの利用はアンチパターン
- OpenID Connect を利用するには、OIDC Trust と Cloud Roles を準備する。あとは認証アクションを呼び出すだけで、一時クレデンシャルが取得できる
- 事故防止のため、プライベートリポジトリを利用すること。あわせて認証パラメータを Secrets 管理する
- セキュリティを担保するために、別リポジトリからアクセスできないことを確認する
## 12章
TODO
## 13章
TODO
## 14章
TODO
## 15章
TODO
## 16章
TODO
## 17章
TODO
## 18章
TODO

---

- on キーへ schedule イベントを指定することでワークフローを定期実行できる。cron 形式で記述。タイムゾーンは UTC。
- 中間環境変数
  - コンテキストを直接シェルコマンドに埋め込むと、コンテキストによっては特殊文字が含まれ、シェルコマンドの実行に意図しない影響を与えるので中間環境変数を使う。環境ヘンスはすべてダブルクォーテーションで囲むことで、トークン分割やパス名展開が抑制される(シェルの仕様)
- ステップ間のデータ共有
  - 環境変数 `GITHUB_OUTPUT` の利用
    - `GITHUB_OUTPUT` には特殊なファイルパスが格納されている
  - 環境変数 `GITHUB_ENV` の利用
    - `GITHUB_ENV` にも特殊なファイルパスが格納されている
      - ステップIDの指定が不要（ステップ間の依存関係は分かりづらくなる）
      - 事実上グローバル変数なので、ワークフローが大きくなるとバグの温床になりやすいため、不用意な利用は控えるべき
- `GITHUB_TOKEN` シークレット
  - GitHub APIを実行するための認証などに使える特別なクレデンシャル
  - ワークフロー開始時に自動生成され、終了すると自動的に破棄される
  - 通常の Secrets と異なり GitHub Actions が自動生成するため、事前登録が不要
  - `secrets.GITHUB_TOKEN` と `github.token` のどちらでも取得できる。実運用の時は混在させると分かりづらいのでどちらかに寄せる
- Bash の起動オプション
  - Bash の場合、shell キーの有無で起動オプションが変わる
    - 省略時: bash -e {0}
      - パイプ処理中のエラーを無視するため、エラーの発生場所から離れた場所で、予期せず不具合をおこしやすい
    - 記述時: bash --noprofile --norc -eo  pipefail {0}
  - シェル指定は明示的にすべき
  - デフォルトシェル（ワークフローファイルのトップレベル defaults.run.shell: bash ）で指定すると楽
- Concurrency
  - ワークフローの同時実行で不整合が発生する場合、多重機動が問題になるためその対処
  - 自動キャンセル
    - PRをトリガーにするワークフローは、最新コード以外でジョブ実行する必要性が低いので、古いジョブ実行をキャンセルする `concurrency.cancel-in.progress: true` 
- ワークフローコマンドを使うと、echo コマンド経由でランナーへ特殊な操作を指示できる
  - `workflow-command parameter1=<data1>,parameter1=<data2>::<command value>` 
  - `::debug::<message>`
  - デバッグログはデフデフォルトで無効化されているので、GUIで「Enable debug logging」にチェックが必要
- Bash のトレーシングオプション
  - デバッグログよりももっとシンプルに実行コマンドと結果を知りたい場合は、`set -x`
- アノテーションは、エラーメッセージや警告メッセージの確認に便利。ジョブページへ任意のメッセージを出力できる。ワークフローコマンドを使って、error, warning, notice
- シンプルなメッセージの出力ならアノテーションで十分だが、テーブルやリストなど凝った出力にしたい場合は、ジョブサマリー
  - マークダウンテキストを出力すると、ジョブページで綺麗に整形して表示される
  - 環境変数 `GITHUB_STEP_SUMMARY` に入力する
- ジョブの逐次実行には `jobs.{job名}.needs: [{前段のjob名}]`
